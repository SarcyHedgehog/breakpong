<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Pongout3D</title>
  <!-- Added Google Font -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    html, body { margin: 0; overflow: hidden; background: #1e0e1e; }
    #overlay {
      position: absolute;
      top: 20px;
      left: 0; /* Ensure it spans full width */
      right: 0; /* Ensure it spans full width */
      width: auto; /* Allow text-align to work effectively */
      text-align: center;
      /* Added Arcade Font and Size */
      font-family: 'Press Start 2P', cursive; 
      color: white;
      font-size: 48px; 
      z-index: 1;
      text-shadow: 2px 2px #000000; 
      pointer-events: none; 
    }
    /* Added class for smaller messages */
    .small-text { 
        font-size: 24px;
    }
  </style>
  <script type="module">
    // Ensure THREE and Multisynq are imported first
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js';
    import * as Multisynq from 'https://cdn.jsdelivr.net/npm/@multisynq/client@1/bundled/multisynq-client.esm.js';

    // --- Constants ---
    const C = { paddleSpeed: 0.1, ballSpeed: 0.05, winScore: 10 };
    const MODEL_TICK_RATE_MS = 33;
    const BALL_RADIUS = 0.1;
    const BRICK_COLLISION_EPSILON = 0.001;
    const COURT_WIDTH = 8.0;
    const COURT_DEPTH = 5.0;

    // Paddle Dimensions & Positions
    const PADDLE_THICKNESS_X = 0.2;
    const PADDLE_VISUAL_HEIGHT_Y = 0.2;
    const PADDLE_LENGTH_Z = 1.2;
    const PADDLE_VIEW_X_OFFSET_FROM_EDGE = 0.1;
    const PADDLE_MODEL_CENTER_X_ABS = COURT_WIDTH/2 - PADDLE_THICKNESS_X/2 - PADDLE_VIEW_X_OFFSET_FROM_EDGE;
    const PADDLE1_MODEL_CENTER_X = -PADDLE_MODEL_CENTER_X_ABS;
    const PADDLE2_MODEL_CENTER_X = PADDLE_MODEL_CENTER_X_ABS;
    const PADDLE1_INNER_EDGE_X = PADDLE1_MODEL_CENTER_X + PADDLE_THICKNESS_X / 2;
    const PADDLE2_INNER_EDGE_X = PADDLE2_MODEL_CENTER_X - PADDLE_THICKNESS_X / 2;

    // Brick Wall Structure
    const WALL_BRICK_WIDTH = 0.25;
    const WALL_BRICK_DEPTH = 0.5;
    const WALL_NUM_BRICK_SEGMENTS_WIDE = 5;
    const WALL_TOTAL_WIDTH = WALL_NUM_BRICK_SEGMENTS_WIDE * WALL_BRICK_WIDTH; // 1.25
    const WALL_NUM_ROWS_DEEP = Math.round(COURT_DEPTH / WALL_BRICK_DEPTH); // 10
    const BRICK_VISUAL_HEIGHT_Y = 0.2;
    const RED_BRICK_CHANCE = 0.15; // NEW: 15% chance

    // Portal Constants
    const PORTAL_RADIUS = BALL_RADIUS * 1.8;
    const PORTAL_COLOR_P1 = 0x0077ff;
    const PORTAL_COLOR_P2 = 0xffaa00;
    const PORTAL_TUBE_RADIUS_FACTOR = 0.20;
    const PORTAL_COOLDOWN_MS = 750;
    const PORTAL_SPEED_FACTOR = 0.3;
    const PORTAL_PADDLE_SIDE_X_MARGIN = 0.2;

    // Portal Movement Boundaries (Static, for Center) - From your good code
    const P1_PORTAL_X_OUTER_BOUNDARY_CENTER = PADDLE1_INNER_EDGE_X + PORTAL_RADIUS + PORTAL_PADDLE_SIDE_X_MARGIN;
    const P1_PORTAL_X_INNER_BOUNDARY_CENTER = -(WALL_TOTAL_WIDTH / 2) - PORTAL_RADIUS;
    const P2_PORTAL_X_INNER_BOUNDARY_CENTER = (WALL_TOTAL_WIDTH / 2) + PORTAL_RADIUS;
    const P2_PORTAL_X_OUTER_BOUNDARY_CENTER = PADDLE2_INNER_EDGE_X - PORTAL_RADIUS - PORTAL_PADDLE_SIDE_X_MARGIN;

    // Initial Portal Positions
    const PORTAL_1_INITIAL_X = (P1_PORTAL_X_OUTER_BOUNDARY_CENTER + P1_PORTAL_X_INNER_BOUNDARY_CENTER) / 2;
    const PORTAL_1_INITIAL_Y = 0;
    const PORTAL_2_INITIAL_X = (P2_PORTAL_X_INNER_BOUNDARY_CENTER + P2_PORTAL_X_OUTER_BOUNDARY_CENTER) / 2;
    const PORTAL_2_INITIAL_Y = 0;

    // Brick Colors - NEW
    const BRICK_COLOR_GREEN = 0x00bb00;
    const BRICK_COLOR_RED = 0xcc0000;

    // --- PongModel Class ---
    class PongModel extends Multisynq.Model {
      init() {
        this.players = {};
        this.paddleY = { 1: 0, 2: 0 };
        this.ball = { x: 0, y: 0, vx: 0, vy: 0, lastPortalHit: null, portalCooldown: 0 };
        this.score = { 1: 0, 2: 0 };
        this.state = "waiting"; // Added serving_paused possibility
        this.countdown = 5;
        this.bricks = this.initBricks(); // Calls modified initBricks
        this.lastStarter = 2; // P1 serves first
        this.servingPlayer = 1; // Added servingPlayer tracker

        const portalBaseSpeed = C.ballSpeed * PORTAL_SPEED_FACTOR;
        // Renamed boundary vars to make clear they are for portal center
        const portalMinYBoundary_center = -COURT_DEPTH / 2 + PORTAL_RADIUS;
        const portalMaxYBoundary_center = COURT_DEPTH / 2 - PORTAL_RADIUS;

        this.portals = {
          // Using boundaries for center logic from your good code's constants
          '1': {
            id: '1', x: PORTAL_1_INITIAL_X, y: PORTAL_1_INITIAL_Y,
            radius: PORTAL_RADIUS, color: PORTAL_COLOR_P1,
            vx: (Math.random() > 0.5 ? 1 : -1) * portalBaseSpeed * (Math.random() * 0.4 + 0.8),
            vy: (Math.random() > 0.5 ? 1 : -1) * portalBaseSpeed * (Math.random() * 0.4 + 0.8),
            minX_center: P1_PORTAL_X_OUTER_BOUNDARY_CENTER, // Outer limit (paddle side)
            maxX_center: P1_PORTAL_X_INNER_BOUNDARY_CENTER, // Inner limit (wall side)
            minY_center: portalMinYBoundary_center,
            maxY_center: portalMaxYBoundary_center
          },
          '2': {
            id: '2', x: PORTAL_2_INITIAL_X, y: PORTAL_2_INITIAL_Y,
            radius: PORTAL_RADIUS, color: PORTAL_COLOR_P2,
            vx: (Math.random() > 0.5 ? 1 : -1) * portalBaseSpeed * (Math.random() * 0.4 + 0.8),
            vy: (Math.random() > 0.5 ? 1 : -1) * portalBaseSpeed * (Math.random() * 0.4 + 0.8),
            minX_center: P2_PORTAL_X_INNER_BOUNDARY_CENTER, // Inner limit (wall side)
            maxX_center: P2_PORTAL_X_OUTER_BOUNDARY_CENTER, // Outer limit (paddle side)
            minY_center: portalMinYBoundary_center,
            maxY_center: portalMaxYBoundary_center
          }
        };

        this.subscribe(this.sessionId, "view-join", this.onJoin);
        this.subscribe(this.sessionId, "view-exit", this.onLeave);
        this.subscribe(this.sessionId, "move", this.onMove);
        this.future(MODEL_TICK_RATE_MS).step();
      } // End init

      initBricks() { // Modified for Red Bricks
        const bricks = [];
        const startModelX = -(WALL_TOTAL_WIDTH / 2) + (WALL_BRICK_WIDTH / 2);
        const startModelY = (COURT_DEPTH / 2) - (WALL_BRICK_DEPTH / 2);
        for (let r = 0; r < WALL_NUM_ROWS_DEEP; r++) {
            const currentBrickRowModelY = startModelY - r * WALL_BRICK_DEPTH;
            for (let c = 0; c < WALL_NUM_BRICK_SEGMENTS_WIDE; c++) {
                const isRed = Math.random() < RED_BRICK_CHANCE; // NEW
                bricks.push({
                    x: startModelX + c * WALL_BRICK_WIDTH, y: currentBrickRowModelY,
                    width: WALL_BRICK_WIDTH, depth: WALL_BRICK_DEPTH,
                    // NEW properties for color/hits
                    color: isRed ? BRICK_COLOR_RED : BRICK_COLOR_GREEN,
                    hits: isRed ? 2 : 1,
                    initialColor: isRed ? BRICK_COLOR_RED : BRICK_COLOR_GREEN
                });
            }
        }
        return bricks;
      } // End initBricks

      resetPortals() { // NEW Helper
        const portalBaseSpeed = C.ballSpeed * PORTAL_SPEED_FACTOR;
        this.portals['1'].x = PORTAL_1_INITIAL_X; this.portals['1'].y = PORTAL_1_INITIAL_Y;
        this.portals['1'].vx = (Math.random() > 0.5 ? 1 : -1) * portalBaseSpeed * (Math.random() * 0.4 + 0.8);
        this.portals['1'].vy = (Math.random() > 0.5 ? 1 : -1) * portalBaseSpeed * (Math.random() * 0.4 + 0.8);
        this.portals['2'].x = PORTAL_2_INITIAL_X; this.portals['2'].y = PORTAL_2_INITIAL_Y;
        this.portals['2'].vx = (Math.random() > 0.5 ? 1 : -1) * portalBaseSpeed * (Math.random() * 0.4 + 0.8);
        this.portals['2'].vy = (Math.random() > 0.5 ? 1 : -1) * portalBaseSpeed * (Math.random() * 0.4 + 0.8);
      } // End resetPortals

      onJoin({ viewId }) { // Unchanged from your good code
        if (Object.values(this.players).includes(viewId)) return;
        if (!this.players[1]) this.players[1] = viewId;
        else if (!this.players[2]) this.players[2] = viewId;
        if (Object.keys(this.players).length === 2 && this.state === "waiting") {
          this.startCountdown();
        }
        this.publish("ui", "state", this.snapshot());
      } // End onJoin

      onLeave({ viewId }) { // Unchanged from your good code
        const player = this.getPlayerNumber(viewId);
        if (!player) return;
        delete this.players[player];
        this.state = "disconnected"; this.ball.vx = 0; this.ball.vy = 0;
        this.publish("ui", "state", this.snapshot());
      } // End onLeave

      onMove({ viewId, dy }) { // Modified to allow move during pause & update ball pos
        const player = this.getPlayerNumber(viewId);
        if (player && (this.state === "playing" || this.state === "serving_paused")) {
          this.paddleY[player] += dy;
          const paddleHalfLength = PADDLE_LENGTH_Z / 2;
          const maxPaddleModelY = (COURT_DEPTH / 2) - paddleHalfLength;
          this.paddleY[player] = Math.max(-maxPaddleModelY, Math.min(maxPaddleModelY, this.paddleY[player]));
          // If paused, update ball Y position too so it stays on paddle
          if (this.state === "serving_paused" && this.servingPlayer === player) {
              this.ball.y = this.paddleY[player];
              // Publish state immediately on move during pause if needed for smoothness
              // this.publish("ui", "state", this.snapshot());
          }
        }
      } // End onMove

      getPlayerNumber(id) { // Unchanged from your good code
        return Object.entries(this.players).find(([, v]) => v === id)?.[0];
      } // End getPlayerNumber

      startCountdown() { // Modified to set servingPlayer
        this.countdown = 5; this.state = "countdown";
        this.servingPlayer = this.lastStarter === 1 ? 2 : 1;
        this.future(1000).countdownTick();
      } // End startCountdown

      countdownTick() { // Modified to call prepareServe
        this.countdown--;
        if (this.countdown <= 0) {
          this.lastStarter = this.servingPlayer; // Update who started last
          this.prepareServe(); // Place ball, start pause
        } else {
          this.future(1000).countdownTick();
        }
        this.publish("ui", "state", this.snapshot());
      } // End countdownTick

      prepareServe() { // NEW Method for pause logic
        const dir = this.servingPlayer === 1 ? 1 : -1;
        const ballStartX = this.servingPlayer === 1 ? PADDLE1_INNER_EDGE_X + BALL_RADIUS + 0.05 : PADDLE2_INNER_EDGE_X - BALL_RADIUS - 0.05;
        const ballStartY = this.paddleY[this.servingPlayer];
        // Reset ball state, velocity is 0 for now
        this.ball = { ...this.ball, x: ballStartX, y: ballStartY, vx: 0, vy: 0, portalCooldown: 0, lastPortalHit: null };
        this.state = "serving_paused";
        this.publish("ui", "state", this.snapshot()); // Show ball placement
        this.future(1000).executeServe(); // Wait 1 sec
      } // End prepareServe

      executeServe() { // NEW Method for pause logic
        if (this.state !== "serving_paused") return; // Safety check
        const dir = this.servingPlayer === 1 ? 1 : -1;
        this.ball.vx = dir * C.ballSpeed;
        this.ball.vy = 0; // Serve straight
        this.state = "playing";
        this.publish("ui", "state", this.snapshot()); // Ensure state change is sent
      } // End executeServe

      step() {
        if (this.state === "playing" || this.state === "serving_paused") {
          // 1. Portal Movement and Boundary/Paddle Collisions (Using logic from your good code)
          const PORTAL_PADDLE_EPSILON = 0.01; // Moved epsilon here
          for (const portalId in this.portals) {
            const portal = this.portals[portalId];
            portal.x += portal.vx;
            portal.y += portal.vy;

            // Y collision (using center bounds)
            if (portal.y < portal.minY_center) { portal.y = portal.minY_center; portal.vy *= -1; }
             else if (portal.y > portal.maxY_center) { portal.y = portal.maxY_center; portal.vy *= -1; }

            // X collision (using center bounds)
            if (portal.x < portal.minX_center) { portal.x = portal.minX_center; portal.vx *= -1; }
             else if (portal.x > portal.maxX_center) { portal.x = portal.maxX_center; portal.vx *= -1; }

             // --- Portal-Paddle Collision (Copied from your good code's logic structure) ---
             const portalHalfSize = portal.radius;
             // Check collision with Paddle 1
             const paddle1HalfThick = PADDLE_THICKNESS_X / 2; const paddle1HalfLen = PADDLE_LENGTH_Z / 2;
             const paddle1Y = this.paddleY[1];
             const dx1 = portal.x - PADDLE1_MODEL_CENTER_X; const dy1 = portal.y - paddle1Y;
             const combinedHalfWidths1 = portalHalfSize + paddle1HalfThick; const combinedHalfDepths1 = portalHalfSize + paddle1HalfLen;
             if (Math.abs(dx1) < combinedHalfWidths1 && Math.abs(dy1) < combinedHalfDepths1) {
                 const overlapX1 = combinedHalfWidths1 - Math.abs(dx1); const overlapY1 = combinedHalfDepths1 - Math.abs(dy1);
                 if (overlapX1 < overlapY1) { portal.x = PADDLE1_MODEL_CENTER_X + Math.sign(dx1) * (combinedHalfWidths1 + PORTAL_PADDLE_EPSILON); portal.vx *= -1;}
                  else { portal.y = paddle1Y + Math.sign(dy1) * (combinedHalfDepths1 + PORTAL_PADDLE_EPSILON); portal.vy *= -1; }
             }
             // Check collision with Paddle 2
             const paddle2HalfThick = PADDLE_THICKNESS_X / 2; const paddle2HalfLen = PADDLE_LENGTH_Z / 2;
             const paddle2Y = this.paddleY[2];
             const dx2 = portal.x - PADDLE2_MODEL_CENTER_X; const dy2 = portal.y - paddle2Y;
             const combinedHalfWidths2 = portalHalfSize + paddle2HalfThick; const combinedHalfDepths2 = portalHalfSize + paddle2HalfLen;
             if (Math.abs(dx2) < combinedHalfWidths2 && Math.abs(dy2) < combinedHalfDepths2) {
                 const overlapX2 = combinedHalfWidths2 - Math.abs(dx2); const overlapY2 = combinedHalfDepths2 - Math.abs(dy2);
                 if (overlapX2 < overlapY2) { portal.x = PADDLE2_MODEL_CENTER_X + Math.sign(dx2) * (combinedHalfWidths2 + PORTAL_PADDLE_EPSILON); portal.vx *= -1; }
                  else { portal.y = paddle2Y + Math.sign(dy2) * (combinedHalfDepths2 + PORTAL_PADDLE_EPSILON); portal.vy *= -1; }
             }
          } // End portal loop

          // Only do ball physics and game logic if actually playing
          if (this.state === "playing") {
            // Ball Cooldown for Portal
            if (this.ball.portalCooldown > 0) {
              this.ball.portalCooldown -= MODEL_TICK_RATE_MS;
              if (this.ball.portalCooldown <= 0) { this.ball.lastPortalHit = null; }
            }

            // Ball Movement
            this.ball.x += this.ball.vx; this.ball.y += this.ball.vy;

            // Ball Wall Collision (Top/Bottom)
            const courtHalfDepth = COURT_DEPTH / 2;
            if (this.ball.y + BALL_RADIUS > courtHalfDepth || this.ball.y - BALL_RADIUS < -courtHalfDepth) {
              this.ball.vy *= -1;
              this.ball.y = Math.max(-courtHalfDepth + BALL_RADIUS, Math.min(courtHalfDepth - BALL_RADIUS, this.ball.y));
            }

            // Ball Paddle Collision
            const paddleLogicalHalfLength = PADDLE_LENGTH_Z / 2;
            if (this.ball.vx < 0 && this.ball.x - BALL_RADIUS < PADDLE1_INNER_EDGE_X && this.ball.x + BALL_RADIUS > PADDLE1_MODEL_CENTER_X - PADDLE_THICKNESS_X / 2 && Math.abs(this.ball.y - this.paddleY[1]) < (paddleLogicalHalfLength + BALL_RADIUS)) {
              this.ball.vx *= -1; this.ball.x = PADDLE1_INNER_EDGE_X + BALL_RADIUS + BRICK_COLLISION_EPSILON;
              this.ball.vy += (this.ball.y - this.paddleY[1]) * 0.15 * Math.abs(this.ball.vx) / C.ballSpeed;
              this.ball.vy = Math.max(-C.ballSpeed*2, Math.min(C.ballSpeed*2, this.ball.vy));
            } else if (this.ball.vx > 0 && this.ball.x + BALL_RADIUS > PADDLE2_INNER_EDGE_X && this.ball.x - BALL_RADIUS < PADDLE2_MODEL_CENTER_X + PADDLE_THICKNESS_X / 2 && Math.abs(this.ball.y - this.paddleY[2]) < (paddleLogicalHalfLength + BALL_RADIUS)) {
              this.ball.vx *= -1; this.ball.x = PADDLE2_INNER_EDGE_X - BALL_RADIUS - BRICK_COLLISION_EPSILON;
              this.ball.vy += (this.ball.y - this.paddleY[2]) * 0.15 * Math.abs(this.ball.vx) / C.ballSpeed;
              this.ball.vy = Math.max(-C.ballSpeed*2, Math.min(C.ballSpeed*2, this.ball.vy));
            }

            // Ball Brick Collision (Modified for Hits/Color)
            let hitBrickThisStep = false;
            const remainingBricks = [];
            for (const brick of this.bricks) {
                let currentBrickDestroyed = false;
                const brickHalfWidth = brick.width / 2; const brickHalfDepth = brick.depth / 2;
                const dx_brick = this.ball.x - brick.x; const dy_brick = this.ball.y - brick.y;
                const combinedHalfWidths = BALL_RADIUS + brickHalfWidth; const combinedHalfDepths = BALL_RADIUS + brickHalfDepth;
                if (Math.abs(dx_brick) < combinedHalfWidths && Math.abs(dy_brick) < combinedHalfDepths) {
                    hitBrickThisStep = true;
                    brick.hits--; // Decrement hits
                    if (brick.hits <= 0) {
                        currentBrickDestroyed = true; // Mark for removal
                    } else if (brick.initialColor === BRICK_COLOR_RED && brick.hits === 1) { // Check initialColor
                        brick.color = BRICK_COLOR_GREEN; // Change to green
                    }
                    // Bounce logic (unchanged)
                    const overlapX = combinedHalfWidths - Math.abs(dx_brick); const overlapY = combinedHalfDepths - Math.abs(dy_brick);
                    if (overlapX < overlapY && overlapX > BRICK_COLLISION_EPSILON) {
                        if (dx_brick > 0) this.ball.x = brick.x + brickHalfWidth + BALL_RADIUS + BRICK_COLLISION_EPSILON; else this.ball.x = brick.x - brickHalfWidth - BALL_RADIUS - BRICK_COLLISION_EPSILON;
                        this.ball.vx *= -1;
                    } else if (overlapY < overlapX && overlapY > BRICK_COLLISION_EPSILON) {
                        if (dy_brick > 0) this.ball.y = brick.y + brickHalfDepth + BALL_RADIUS + BRICK_COLLISION_EPSILON; else this.ball.y = brick.y - brickHalfDepth - BALL_RADIUS - BRICK_COLLISION_EPSILON;
                        this.ball.vy *= -1;
                    } else {
                        this.ball.x = brick.x + Math.sign(dx_brick) * (brickHalfWidth + BALL_RADIUS + BRICK_COLLISION_EPSILON); this.ball.y = brick.y + Math.sign(dy_brick) * (brickHalfDepth + BALL_RADIUS + BRICK_COLLISION_EPSILON);
                        this.ball.vx *= -1; this.ball.vy *= -1;
                    }
                }
                if (!currentBrickDestroyed) remainingBricks.push(brick);
            }
            this.bricks = remainingBricks;

            // Ball Portal Teleportation (Unchanged from your good code)
            if (!hitBrickThisStep && this.ball.portalCooldown <= 0) {
              for (const portalId in this.portals) {
                const portal = this.portals[portalId];
                const dx_portal = this.ball.x - portal.x; const dy_portal = this.ball.y - portal.y;
                const distance = Math.sqrt(dx_portal * dx_portal + dy_portal * dy_portal);
                if (distance < (BALL_RADIUS + portal.radius)) {
                  if (this.ball.lastPortalHit !== portal.id) {
                    const otherPortalId = portal.id === '1' ? '2' : '1';
                    const otherPortal = this.portals[otherPortalId];
                    this.ball.x = otherPortal.x; this.ball.y = otherPortal.y;
                    const velocityMagnitude = Math.sqrt(this.ball.vx * this.ball.vx + this.ball.vy * this.ball.vy);
                    if (velocityMagnitude > 0) {
                        const normVx = this.ball.vx / velocityMagnitude; const normVy = this.ball.vy / velocityMagnitude;
                        this.ball.x += normVx * (otherPortal.radius + BALL_RADIUS + BRICK_COLLISION_EPSILON * 5);
                        this.ball.y += normVy * (otherPortal.radius + BALL_RADIUS + BRICK_COLLISION_EPSILON * 5);
                    }
                    this.ball.lastPortalHit = otherPortalId; this.ball.portalCooldown = PORTAL_COOLDOWN_MS;
                    break;
                  }
                }
              }
            }

            // Scoring
            const courtHalfWidth = COURT_WIDTH / 2;
            if (this.ball.x < -courtHalfWidth) { this.score[2]++; this.checkWin(2); }
            else if (this.ball.x > courtHalfWidth) { this.score[1]++; this.checkWin(1); }
          } // end if (this.state === "playing")
        } // end if (this.state === "playing" || this.state === "serving_paused")
        this.publish("ui", "state", this.snapshot());
        this.future(MODEL_TICK_RATE_MS).step();
      } // End of step()

      checkWin(scorer) { // Modified for pause and portal reset
        if (this.score[1] >= C.winScore || this.score[2] >= C.winScore) {
          const winner = this.score[1] >= C.winScore ? 1 : 2;
          this.state = `won${winner}`; this.score = { 1: 0, 2: 0 };
          this.bricks = this.initBricks();
          this.resetPortals(); // Reset portal positions/velocities
          this.future(5000).startCountdown(); // Calls startCountdown, which sets servingPlayer
        } else {
          this.servingPlayer = scorer === 1 ? 2 : 1; // Player who didn't score serves next
          this.lastStarter = this.servingPlayer; // Update last starter for next game potentially
          this.prepareServe(); // Sets ball position and state to "serving_paused"
        }
      } // End of checkWin()

      snapshot() { // Modified to send color/hits for bricks
        return {
          paddleY: this.paddleY,
          ball: { x: this.ball.x, y: this.ball.y },
          score: this.score, state: this.state, countdown: this.countdown,
          // Send necessary brick info for rendering
          bricks: this.bricks.map(b => ({
              x: b.x, y: b.y, width: b.width, depth: b.depth, color: b.color // Send color
          })),
          portals: this.portals
        };
      } // End of snapshot()
    } // End of PongModel class
    PongModel.register("PongModel");

    // --- PongView Class ---
    class PongView extends Multisynq.View {
        constructor(model) {
            super(model);
            this.model = model;
            this.overlay = document.getElementById("overlay");
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
            this.portalMeshes = {};
            this.brickMap = new Map();
            this.camera.position.set(0, COURT_WIDTH * 0.5, COURT_DEPTH * 1.2);
            this.camera.lookAt(0, 0, 0);
            this.renderer = new THREE.WebGLRenderer({ antialias: true });
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(this.renderer.domElement);
            this.resize();
            window.addEventListener("resize", () => this.resize());
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            const directional = new THREE.DirectionalLight(0xffffff, 0.8);
            directional.position.set(COURT_WIDTH * 0.5, COURT_DEPTH * 1.5, COURT_DEPTH * 0.75);
            directional.castShadow = true;
            directional.shadow.mapSize.width = 1024; directional.shadow.mapSize.height = 1024;
            directional.shadow.camera.near = 0.5; directional.shadow.camera.far = COURT_DEPTH * 3;
            directional.shadow.camera.left = -COURT_WIDTH / 2 - 2; directional.shadow.camera.right = COURT_WIDTH / 2 + 2;
            directional.shadow.camera.top = COURT_DEPTH / 2 + 2; directional.shadow.camera.bottom = -COURT_DEPTH / 2 - 2;
            this.scene.add(ambient, directional);
            const court = new THREE.Mesh(new THREE.PlaneGeometry(COURT_WIDTH, COURT_DEPTH), new THREE.MeshStandardMaterial({ color: 0x3d0f3d, side: THREE.DoubleSide, roughness: 0.9 }));
            court.rotation.x = -Math.PI / 2; court.receiveShadow = true;
            this.scene.add(court);
            this.paddle1 = new THREE.Mesh(new THREE.BoxGeometry(PADDLE_THICKNESS_X, PADDLE_VISUAL_HEIGHT_Y, PADDLE_LENGTH_Z), new THREE.MeshStandardMaterial({ color: 0x0057cc, metalness: 0.4, roughness: 0.5 }));
            this.paddle2 = new THREE.Mesh(new THREE.BoxGeometry(PADDLE_THICKNESS_X, PADDLE_VISUAL_HEIGHT_Y, PADDLE_LENGTH_Z), new THREE.MeshStandardMaterial({ color: 0xff8800, metalness: 0.4, roughness: 0.5 }));
            this.paddle1.position.set(PADDLE1_MODEL_CENTER_X, PADDLE_VISUAL_HEIGHT_Y / 2, 0);
            this.paddle2.position.set(PADDLE2_MODEL_CENTER_X, PADDLE_VISUAL_HEIGHT_Y / 2, 0);
            this.paddle1.castShadow = true; this.paddle2.castShadow = true;
            this.ball = new THREE.Mesh(new THREE.SphereGeometry(BALL_RADIUS, 32, 16), new THREE.MeshStandardMaterial({ color: 0xf0f0f0, metalness: 0.5, roughness: 0.3, emissive: 0x111111 }));
            this.ball.castShadow = true;
            this.scene.add(this.paddle1, this.paddle2, this.ball);
            this.subscribe("ui", "state", this.renderState);
            this.publish(this.model.sessionId, "view-join", { viewId: this.viewId });
            this.animate();
            this.handleInput();
        } // End constructor

      resize() {
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setPixelRatio(window.devicePixelRatio);
      } // End resize

      renderState(state) { // Modified for brick color update and overlay text
        this.paddle1.position.z = state.paddleY[1];
        this.paddle2.position.z = state.paddleY[2];
        this.ball.position.set(state.ball.x, BALL_RADIUS, state.ball.y);

        for (const portalId in state.portals) {
          const portalData = state.portals[portalId];
          if (!this.portalMeshes[portalId]) {
            const geometry = new THREE.TorusGeometry(portalData.radius, portalData.radius * PORTAL_TUBE_RADIUS_FACTOR, 16, 48);
            const material = new THREE.MeshStandardMaterial({ color: portalData.color, emissive: portalData.color, emissiveIntensity: 0.8, metalness: 0.2, roughness: 0.5, side: THREE.DoubleSide });
            this.portalMeshes[portalId] = new THREE.Mesh(geometry, material);
            this.portalMeshes[portalId].rotation.x = Math.PI / 2;
            this.portalMeshes[portalId].castShadow = false;
            this.scene.add(this.portalMeshes[portalId]);
          }
          this.portalMeshes[portalId].position.set(portalData.x, PADDLE_VISUAL_HEIGHT_Y / 2 + 0.01, portalData.y);
        }

        const seenBrickKeys = new Set();
        state.bricks.forEach(brickData => {
          const key = `${brickData.x.toFixed(4)},${brickData.y.toFixed(4)}`;
          seenBrickKeys.add(key);
          let brickMesh = this.brickMap.get(key);
          if (!brickMesh) {
            // Create new brick mesh using color from model
            brickMesh = new THREE.Mesh(
              new THREE.BoxGeometry(brickData.width, BRICK_VISUAL_HEIGHT_Y, brickData.depth),
              new THREE.MeshStandardMaterial({ color: brickData.color, metalness: 0.2, roughness: 0.7, emissive: brickData.color === BRICK_COLOR_RED ? 0x330000 : 0x002200 })
            );
            brickMesh.position.set(brickData.x, BRICK_VISUAL_HEIGHT_Y / 2, brickData.y);
            brickMesh.castShadow = true; brickMesh.receiveShadow = true;
            this.scene.add(brickMesh); this.brickMap.set(key, brickMesh);
          } else {
            // Update existing brick mesh color if needed
            if (brickMesh.material.color.getHex() !== brickData.color) {
                brickMesh.material.color.setHex(brickData.color);
                brickMesh.material.emissive.setHex(brickData.color === BRICK_COLOR_RED ? 0x330000 : 0x002200);
            }
          }
        });
        for (const [key, mesh] of this.brickMap.entries()) {
          if (!seenBrickKeys.has(key)) {
            this.scene.remove(mesh); mesh.geometry.dispose(); mesh.material.dispose();
            this.brickMap.delete(key);
          }
        }

        // Update overlay text (Modified for pause state and small text class)
        this.overlay.className = '';
        if (state.state === "waiting") this.overlay.textContent = "Waiting for players...";
        else if (state.state === "countdown") this.overlay.textContent = `Game starts in ${state.countdown}`;
        else if (state.state === "playing" || state.state === "serving_paused") { // Show score during pause too
             this.overlay.textContent = `${state.score[1]} : ${state.score[2]}`;
        }
        else if (state.state === "won1") {this.overlay.textContent = "Player 1 Wins!"; this.overlay.className = 'small-text';}
        else if (state.state === "won2") {this.overlay.textContent = "Player 2 Wins!"; this.overlay.className = 'small-text';}
        else if (state.state === "disconnected") {this.overlay.textContent = `Player left. Waiting...`; this.overlay.className = 'small-text';}
      } // End renderState

      animate() {
        requestAnimationFrame(() => this.animate());
        this.renderer.render(this.scene, this.camera);
      } // End animate

      handleInput() {
        const keys = {};
        window.addEventListener("keydown", e => { keys[e.code] = true; });
        window.addEventListener("keyup", e => { keys[e.code] = false; });
        const loop = () => {
          let dy = 0;
          if (keys["ArrowUp"] || keys["KeyW"]) dy -= C.paddleSpeed;   // Closer
          if (keys["ArrowDown"] || keys["KeyS"]) dy += C.paddleSpeed; // Further
          if (dy !== 0) this.publish(this.model.sessionId, "move", { viewId: this.viewId, dy });
          requestAnimationFrame(loop);
        };
        loop();
      } // End handleInput
    } // End PongView class

    // --- Join Multisynq Session ---
    Multisynq.Session.join({
      apiKey: "2atXt6dTbNaKKO83iB4tsYDfmpusH0C6veTYXjy7Om",
      appId: "com.sarcastichedgehog.pongout3d",
      name: Multisynq.App.autoSession(),
      password: Multisynq.App.autoPassword(),
      model: PongModel,
      view: PongView
    });

  </script>
</head>
<body>
  <div id="overlay">Loadingâ€¦</div>
</body>
</html>